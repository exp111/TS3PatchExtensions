#include <thread>
#include <chrono>
#include <memory>
#include <iostream>
#include <api/api.h>
#include <helpers.h>
#include "shittyExploits.h"
#include "QtConfig.h"
#include "config.h"

using namespace std;
using namespace std::chrono;
namespace api = wolverindev::ts;

std::string pluginId;
struct TS3Functions functions{};
struct wolverindev::ts::ApiFunctions hook_functions{};

auto exploit_deleter = [](api::Hook* instance) {
	if(instance && hook_functions.unregisterHook)
		hook_functions.unregisterHook(instance);
	delete instance;
};
unique_ptr<api::Hook, decltype(exploit_deleter)> exploit_hook(nullptr, exploit_deleter);


void ts3plugin_freeMemory(void *data) {
	if (data) free(data);
}

void ts3plugin_setFunctionPointers(const struct TS3Functions funcs) {
	functions = funcs;
}

void ts3plugin_registerPluginID(const char *id) {
	pluginId = id;
}

const char *ts3plugin_name() {
	return "Hook [shittyExploits]";
}

const char *ts3plugin_version() {
	return "1.0";
}

int ts3plugin_apiVersion() {
	return 23;
}

const char *ts3plugin_author() {
	return "Exp";
}

const char *ts3plugin_description() {
	return "Fuck TeamSpeak up.";
}

int ts3plugin_init() { 
	printf("%s: Library hook initialized\n", ts3plugin_name());

	//If we get initialized after the hook we dont recive the hook_initialized event so we have to notify the hook that we're alive!
	//Defined within the API
	trigger_plugin_loaded();

	char configPath[512];
	functions.getConfigPath(configPath, 512);

	config->setDirectory(string(configPath) + "plugins/shittyExploits/");
	config->readConfig();

	return 0;
}

void ts3plugin_shutdown() {
	printf("%s: Library hook deinitialized\n", ts3plugin_name());

	if(exploit_hook) hook_functions.unregisterHook(exploit_hook.get());
	hook_functions = {};
}

int ts3plugin_offersConfigure() {
	return PLUGIN_OFFERS_CONFIGURE_QT_THREAD;
}

void ts3plugin_configure(void* handle, void* qParentWidget)
{
	Q_UNUSED(handle);
	QtConfig* cfg = new QtConfig((QWidget*)qParentWidget);
	cfg->setAttribute(Qt::WA_DeleteOnClose);
	cfg->show();
}

string escape(string toEscape)
{
	string buf = toEscape;
	for (int i = 0; i < buf.size(); i++)
	{
		if (buf[i] == ' ')
		{
			buf[i] = '\\';
			buf.insert(buf.begin() + i + 1, 's');
		}
	}

	return buf;
}

void addToEnd(string &cmd, string findS, int value, bool &changed)
{
	if (findS.empty() || cmd.find(findS) == string::npos)
	{
		if (cmd.back() != ' ')
			cmd += ' ';

		cmd += findS + to_string(value);
		changed = true;
	}
}

void addToEnd(string &cmd, string findS, string value, bool &changed)
{
	if (findS.empty() || cmd.find(findS) == string::npos)
	{
		if (cmd.back() != ' ')
			cmd += ' ';

		cmd += findS + value;
		changed = true;
	}
}

void onPacketOut(api::SCHId schId, api::CommandPacket* command, bool &canceled)
{
	string cmd = command->data();
	// Self Kick
	if (cmd == "sendtextmessage targetmode=2 msg=~clientinit")
	{
		command->data("clientinit");
		return;
	}

	if (cmd.substr(0, 11) == "clientinit ")
	{
		// Read in config
		//config->readConfig();

		bool changed = false;
		
		// Is Recording
		if (config->isRecording)
			addToEnd(cmd, "client_is_recording=", config->isRecording, changed);

		// Description
		if (!config->description.empty())
			addToEnd(cmd, "client_description=", escape(config->description), changed);

		// Is Talker
		if (config->isTalker)
			addToEnd(cmd, "client_is_talker=", config->isTalker, changed);

		// Is Channel Commander
		if (config->isChannelCommander)
			addToEnd(cmd, "client_is_channel_commander=", config->isChannelCommander, changed);
			
		// Additional Command
		if (!config->additionalCommand.empty())
			addToEnd(cmd, "", config->additionalCommand, changed);

		if (changed)
			command->data(cmd);
		
		return;
	}
}

int hook_initialized(const wolverindev::ts::ApiFunctions fn) {
	printf("%s: Hook called me for initialisation!\n", ts3plugin_name());
	hook_functions = fn;

	exploit_hook.reset(new api::Hook());
	exploit_hook->activated = [](){ return true; };
	exploit_hook->on_packet_out = &onPacketOut;
	
	hook_functions.registerHook(exploit_hook.get());
	return 0;
}

void hook_finalized() {
	printf("%s: Hook called me for finalisation!\n", ts3plugin_name());
	if(exploit_hook) hook_functions.unregisterHook(exploit_hook.get());
	hook_functions = {};
}
